package no.uib.probe.csf.pr.touch.view.components.datasetfilters;

import com.itextpdf.text.pdf.codec.Base64;
import com.vaadin.event.LayoutEvents;
import com.vaadin.server.ExternalResource;
import com.vaadin.ui.AbsoluteLayout;
import com.vaadin.ui.Alignment;
import com.vaadin.ui.Image;
import com.vaadin.ui.Label;
import com.vaadin.ui.VerticalLayout;
import com.vaadin.ui.themes.ValoTheme;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Font;
import java.io.IOException;
import java.text.AttributedString;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import org.jfree.chart.ChartRenderingInfo;
import org.jfree.chart.ChartUtilities;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.block.BlockBorder;
import org.jfree.chart.entity.ChartEntity;
import org.jfree.chart.entity.PieSectionEntity;
import org.jfree.chart.labels.PieSectionLabelGenerator;
import org.jfree.chart.plot.PiePlot;
import org.jfree.chart.title.TextTitle;
import org.jfree.data.general.DefaultPieDataset;
import org.jfree.data.general.PieDataset;

/**
 *
 * @author Yehia Farag
 *
 * This class represents the dataset interactive pie chart filter
 */
public abstract class DatasetPieChartFilter extends AbsoluteLayout implements LayoutEvents.LayoutClickListener {

    /**
     * The highlight selection color (required by JFree chart)
     */
    private final Color selectedColor = Color.decode("#197de1");
    /**
     * Map of each category in the chart and its default color (for JFree chart
     * reset coloring)
     */
    private final Map<Comparable, Color> defaultKeyColorMap = new HashMap<>();
    /**
     * Map of category and selected slice color (required by JFree chart)
     */
    private final Map<Comparable, Color> selectedKeyColorMap = new HashMap<>();
    /**
     * Map of category and value (number of datasets)
     */
    private final Map<Comparable, String> valuesMap = new HashMap<>();
    /**
     * The width of the chart
     */
    private final int width;
    /**
     * The height of the chart
     */
    private final int height;
    /**
     * The map of category and current updated dataset indexes
     */
    private final Map<Comparable, List<Integer>> inuseDsIndexesMap;
    /**
     * The set of selected dataset indexes
     */
    private final HashSet<Integer> selectedDsIds = new HashSet<>();
    /**
     * The set of all dataset indexes
     */
    private final HashSet<Integer> fullDsIds = new HashSet<>();
    /**
     * The map of category and each pie-chart slice component
     */
    private final Map<Comparable, PieChartSlice> chartData;
    /**
     * Array of default slice colors (required by JFree chart)
     */
    private final Color[] defaultColors = new Color[]{new Color(110, 177, 206), new Color(219, 169, 1), new Color(213, 8, 8), new Color(4, 180, 95), new Color(174, 180, 4), new Color(10, 255, 14), new Color(244, 250, 88), new Color(255, 0, 64), new Color(246, 216, 206), new Color(189, 189, 189), new Color(255, 128, 0), Color.WHITE};
    /**
     * The main pie-chart JFree plot(required by JFree chart)
     */
    private PiePlot plot;
    /**
     * The main pie-chart JFree chart (required by JFree chart)
     */
    private JFreeChart chart;
    /**
     * The main pie-chart JFree chart rendering information generated by JFree
     * chart and contain all the chart information
     */
    private final ChartRenderingInfo chartRenderingInfo = new ChartRenderingInfo();
    /*
     *The main chart background image (to be updated using jfreechart)
     */
    private final Image chartBackgroundImg;
    /*
     *A wite layout that has the label and turn pie-chart into dount chart
     */
    private final VerticalLayout middleDountLayout;

    /*
     *The chart label contain the total number of datasets
     */
    private final Label selectAllLabel;

    /**
     * Constructor to initialize the main attributes
     *
     * @param filterTitle
     * @param filterId
     * @param filterIndex
     * @param filterHeight
     * @param filterWidth
     */
    public DatasetPieChartFilter(String filterTitle, String filterId, int filterIndex, int filterWidth, int filterHeight) {
        this.width = filterWidth;
        this.height = filterHeight;

        this.setWidth(width, Unit.PIXELS);
        this.setHeight(height, Unit.PIXELS);
        this.chartBackgroundImg = new Image();
        this.addLayoutClickListener(DatasetPieChartFilter.this);
        this.addStyleName("pointer");
        chartBackgroundImg.setWidth(100, Unit.PERCENTAGE);
        chartBackgroundImg.setHeight(100, Unit.PERCENTAGE);
        this.addComponent(chartBackgroundImg, "left: 0px; top: 0px");
        middleDountLayout = new VerticalLayout();

        middleDountLayout.setWidth(120, Unit.PIXELS);
        middleDountLayout.setHeight(120, Unit.PIXELS);

        middleDountLayout.setStyleName("middledountchart");

        selectAllLabel = new Label();
        selectAllLabel.setWidth(30, Unit.PIXELS);
        selectAllLabel.setStyleName(ValoTheme.LABEL_TINY);
        selectAllLabel.addStyleName(ValoTheme.LABEL_SMALL);
        middleDountLayout.addComponent(selectAllLabel);
        middleDountLayout.setComponentAlignment(selectAllLabel, Alignment.MIDDLE_CENTER);

        this.initPieChart(filterTitle);
        this.redrawChart();
        this.inuseDsIndexesMap = new LinkedHashMap<>();
        this.chartData = new LinkedHashMap<>();
    }

    /**
     * Initialize the main JFree chart component
     *
     * @param title
     */
    private void initPieChart(String title) {
        DefaultPieDataset dataset = new DefaultPieDataset();

        plot = new PiePlot(dataset);
        plot.setNoDataMessage("No data available");
        plot.setCircular(true);
        plot.setLabelGap(0);
        plot.setLabelFont(new Font("Helvetica Neue", Font.PLAIN, 13));
        plot.setLabelGenerator(new PieSectionLabelGenerator() {

            @Override
            public String generateSectionLabel(PieDataset pd, Comparable cmprbl) {
                return valuesMap.get(cmprbl);
            }

            @Override
            public AttributedString generateAttributedSectionLabel(PieDataset pd, Comparable cmprbl) {
                throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
            }
        });
        plot.setSimpleLabels(false);
        plot.setLabelBackgroundPaint(null);
        plot.setLabelShadowPaint(null);
        plot.setLabelPaint(Color.GRAY);
        plot.setLabelOutlinePaint(null);

        plot.setBackgroundPaint(Color.WHITE);
        plot.setInteriorGap(0);
        plot.setShadowPaint(Color.WHITE);
        plot.setOutlineVisible(false);
        plot.setBaseSectionOutlinePaint(Color.WHITE);
        plot.setSectionOutlinesVisible(true);
        plot.setBaseSectionOutlineStroke(new BasicStroke(1.2f));
        plot.setInteriorGap(0.05);
        plot.setIgnoreZeroValues(true);

        chart = new JFreeChart(plot);
        TextTitle textTitle = new TextTitle(title, new Font("Helvetica Neue", Font.PLAIN, 13));
        textTitle.setPadding(25, 0, 1, 0);

        chart.setTitle(textTitle);
        chart.getLegend().setItemFont(new Font("Helvetica Neue", Font.PLAIN, 12));

        chart.setBorderPaint(null);
        chart.setBackgroundPaint(null);
        chart.getLegend().setFrame(BlockBorder.NONE);

    }

    /**
     * Convert JFree chart into image and encode it as base64 string to be used
     * as image link
     *
     * @param chart
     * @param width
     * @param height
     */
    private String saveToFile(final JFreeChart chart, double width, double height) {
        byte imageData[];
        try {

            width = Math.max(width, 250);
            height = Math.max(height, 250);

            imageData = ChartUtilities.encodeAsPNG(chart.createBufferedImage((int) width, (int) height, chartRenderingInfo));
            String base64 = Base64.encodeBytes(imageData);
            base64 = "data:image/png;base64," + base64;
            return base64;
        } catch (IOException e) {
            System.err.println("at error " + e.getMessage());
        }
        return "";
    }

    /**
     * This method is responsible for updating pie-chart data
     *
     * @param chartData information required to update chart data
     */
    public void initializeFilterData(Map<Comparable, PieChartSlice> chartData) {
        this.chartData.clear();
        this.chartData.putAll(chartData);
        fullDsIds.clear();
        int coundDs = 0;
        coundDs = chartData.values().stream().map((slice) -> slice.getDatasetIds().size()).reduce(coundDs, Integer::sum);
        this.selectAllLabel.setValue(coundDs + "");
        reset();
    }

    /**
     * This method responsible for invoking the selection action the method to
     * be implemented in the container to maintain pie-chart interactivity
     *
     * @param noselection
     */
    public abstract void selectDatasets(boolean noselection);

    /**
     * Update the chart generated image based on user selection
     */
    private void redrawChart() {
        String imgUrl = saveToFile(chart, width, height);
        this.chartBackgroundImg.setSource(new ExternalResource(imgUrl));
        this.removeComponent(middleDountLayout);
        this.addComponent(middleDountLayout, "left: " + ((chartRenderingInfo.getPlotInfo().getDataArea().getCenterX()) - 60) + "px; top: " + (chartRenderingInfo.getPlotInfo().getDataArea().getCenterY() - 60) + "px");

    }

    /**
     * On chart click (selection on the pie-chart layout)
     *
     * @param event
     */
    @Override
    public void layoutClick(LayoutEvents.LayoutClickEvent event) {
        if (event.getClickedComponent() instanceof VerticalLayout || event.getClickedComponent() instanceof Label) {
            return;
        }

        ChartEntity entity = chartRenderingInfo.getEntityCollection().getEntity(event.getRelativeX(), event.getRelativeY());

        if (entity != null && entity instanceof PieSectionEntity) {
            PieSectionEntity pieEnt = (PieSectionEntity) entity;
            selectSlice(pieEnt.getSectionKey());

        }
    }

    /**
     * Select slice action
     *
     * @param sliceKey
     */
    private void selectSlice(Comparable sliceKey) {

        if (plot.getSectionOutlinePaint(sliceKey) == selectedColor) {
            plot.setSectionOutlinePaint(sliceKey, null);
            plot.setSectionPaint(sliceKey, defaultKeyColorMap.get(sliceKey));
            selectedDsIds.removeAll(chartData.get(sliceKey).getDatasetIds());
        } else {
            plot.setSectionOutlinePaint(sliceKey, selectedColor);
            plot.setSectionPaint(sliceKey, selectedKeyColorMap.get(sliceKey));
            selectedDsIds.addAll(chartData.get(sliceKey).getDatasetIds());

        }
        selectDatasets(selectedDsIds.isEmpty());
        redrawChart();

    }

    /**
     * Check if filter has selected data or empty
     *
     * @return no data selected
     */
    public boolean isActiveFilter() {

        return !selectedDsIds.isEmpty();
    }

    /**
     * Synchronize the pie-chart in response to other pie-charts filter
     *
     * @param selectedDatasetIndexes
     * @param single
     */
    public void localUpdate(Collection<Integer> selectedDatasetIndexes, boolean single) {

        if (single && !selectedDsIds.isEmpty()) {
            selectedDatasetIndexes.clear();
            selectedDatasetIndexes.addAll(fullDsIds);

        }
        this.selectAllLabel.setValue(selectedDatasetIndexes.size() + "");
        valuesMap.clear();
        DefaultPieDataset dataset = (DefaultPieDataset) plot.getDataset();
        dataset.clear();
        chartData.values().stream().forEach((slice) -> {
            int value = 0;
            List<Integer> idList = new ArrayList<>();
            value = selectedDatasetIndexes.stream().filter((id) -> (slice.getDatasetIds().contains(id))).map((id) -> {
                idList.add(id);
                return id;
            }).map((_item) -> 1).reduce(value, Integer::sum);
            inuseDsIndexesMap.put(slice.getLabel(), idList);
            dataset.setValue(slice.getLabel(), value);
            valuesMap.put(slice.getLabel(), value + "");
        });

        redrawChart();
    }

    /**
     * Get selected dataset indexes
     *
     * @return selectedDsIds
     */
    public HashSet<Integer> getSelectedDsIds() {
        if (selectedDsIds.isEmpty()) {
            return fullDsIds;
        }
        return selectedDsIds;
    }

    /**
     * Reset the chart ti initial state
     */
    public void reset() {
        DefaultPieDataset dataset = (DefaultPieDataset) plot.getDataset();
        dataset.clear();
        defaultKeyColorMap.clear();
        selectedKeyColorMap.clear();
        valuesMap.clear();
        inuseDsIndexesMap.clear();
        selectedDsIds.clear();

        Map<Comparable, PieChartSlice> tchartData = new LinkedHashMap<>();
        int counter = 0;
        int coundDs = 0;
        for (PieChartSlice slice : chartData.values()) {
            if (slice.getLabel().toString().trim().equals("")) {
                slice.setLabel("Not Available");
                slice.setColor(Color.LIGHT_GRAY);

            } else {
                slice.setColor(defaultColors[counter++]);
            }
            dataset.setValue(slice.getLabel(), slice.getValue());
            fullDsIds.addAll(slice.getDatasetIds());
            plot.setSectionPaint(slice.getLabel(), slice.getColor());
            plot.setSectionOutlinePaint(slice.getLabel(), null);
            valuesMap.put(slice.getLabel(), slice.getValue() + "");
            defaultKeyColorMap.put(slice.getLabel(), slice.getColor());
            selectedKeyColorMap.put(slice.getLabel(), slice.getColor().darker());
            coundDs += slice.getDatasetIds().size();
            inuseDsIndexesMap.put(slice.getLabel(), new ArrayList<>(slice.getDatasetIds()));
            tchartData.put(slice.getLabel(), slice);
            plot.setExplodePercent(slice.getLabel(), 0);

        }
        this.selectAllLabel.setValue(coundDs + "");
        this.chartData.clear();
        this.chartData.putAll(tchartData);
        redrawChart();

    }
}
